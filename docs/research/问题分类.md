明白了。你要的是**宏观层面的任务设计**与 **面向 DODAF 的时变知识图谱（KG）支撑** ，而不是“拿钥匙→开门”这种微观原子动作清单。下面给你一套可落地的“基准—视图—KG—评测”框架，把 TextWorld/ALFWorld 等环境统一到**系统级任务**与**跨阶段决策**上。

# 宏观任务谱系（Macro Tasks）

> 将原子动作折叠为阶段（phase），每个阶段由策略/资源/约束驱动，并在 KG 中形成时序态迁移。

1. **探索与建图（Explore & Map）**
   目标：从未知环境中建立语义/拓扑/可达图。
   阶段：环境扫描 → 语义标注 → 可达性评估 → 动态障碍更新。
   关键 KG 关系：`place—[connects_to]→place@t`，`region—[blocked_by]→object@t`。
2. **资源获取与启用（Acquire & Enable）**
   目标：定位任务关键资源并解除前置约束（如电源、权限、锁）。
   阶段：资源发现 → 依赖解析（钥匙/电源/容器） → 启用。
   KG：`resource—[requires]→{key, power, permission}`，`container—[locked]→bool@t`。
3. **访问与转运（Access & Transfer）**
   目标：在复杂约束下将目标从 A 转至 B（跨房间/跨容器）。
   阶段：路径规划（携带成本/尺寸） → 取放策略 → 中转/缓冲区。
   KG：`agent—[carrying]→item@t`，`item—[fits_in]→container`，`container—[capacity]→k`。
4. **准备与使用（Prepare & Use）**
   目标：对资源进行加工（清洗、加热、组装）以满足后续任务。
   阶段：设备准备 → 工艺控制（温度/时长） → 质量验收。
   KG：`device—[affords]→{heat, clean, assemble}`，`process—[parameter]→{temp,time}`。
5. **组织与复原（Organize & Restore）**
   目标：全局排序/编组（按优先级/类别/空间最优）并恢复环境到目标态。
   KG：`policy—[sort_by]→{priority, location, category}`。
6. **安全与合规（Safety & Constraints）**
   目标：在风险与资源约束下达成目标（易碎、烫、禁区）。
   KG：`rule—[prohibits]→action@context`，`item—[fragile|hot]→bool`。
7. **多目标协调（Multi-Objective Orchestration）**
   目标：并发/串并混合的子任务编排与冲突消解（手数限制、设备占用）。
   KG：`task_i—[conflicts_with]→task_j`，`resource—[exclusive]→bool`。

# DODAF 对齐（面向系统工程视图）

（用简化映射，方便工程实现）

* **OV-1（作战概览）** ：宏观任务叙事图（上面 1–7 即为能力视图）。
* **OV-5b（活动模型）** ：阶段—子活动—输入/输出—触发条件。
* **OV-6c（事件-致效矩阵）** ：动作→状态变更（时标化）。
* **SV-1（系统接口图）** ：Agent / Environment / Device / KG / Planner 的数据与控制接口。
* **DIV-2（逻辑数据模型）** ：实体—关系—约束模式（见下）。
* **CV-6（能力到活动映射）** ：能力→活动→指标（KPI）绑定。

# 时变知识图谱（基于时间的动态图）

## 数据模式（核心三元组 + 时间与证据）

```
(Entity, Relation, Value/Entity, t_start, t_end, provenance, confidence)

Place(id, type, bbox, affordances)
Object(id, type, size, fragile, hot, power_req, fits_in[])
Device(id, affords[], params={temp_range,time_range}, occupied@t)
Agent(id, hands=2, carry_limit, location@t)
Task(id, goal_spec, preconds[], postconds[], priority)

Relations:
connects_to(place_a, place_b)
in(obj, place|container)
on(obj, support)
locked(container|door), requires(container, key|permission)
carrying(agent, obj)
affords(device, op)  // e.g., heat/clean/assemble
blocked_by(edge, obj)
```

## 状态迁移（动作—效应—约束）

* 形式：`Action(a, args, t) : preconds(KG@t) → effects(ΔKG, t→t+1)`
* 例：`unlock(agent, drawer, key)`
  * 前置：`in(key, agent) ∧ locked(drawer)=true`
  * 效应：`locked(drawer)=false@t+1`；`provenance=policy:unlock`.

## 统一查询 API（建议替代零散 query_kg）

* `need(goal)`: 返回完成目标的最小依赖闭包（keys, power, permissions）。
* `afford(entity)`: 可用操作与参数域。
* `reach(from, to, at=t, carrying=payload)`: 可达/最短路径/绕障解释。
* `fit(item, container)` /** **`capacity(container)` /** **`occupancy(device, t)`.
* `conflicts(task_set)`: 资源/时序/空间冲突与解法建议。
* `simulate(plan)`：基于 KG 的前向验证与失败断言。

# 宏观基准任务与示例（统一到高层目标）

下表把 TextWorld / ALFWorld 融合到宏观能力，而不是细粒度动作：

| 基准任务                          | 决策核心           | 宏观问题模板                               | KG 关键设计（时变）                              |
| --------------------------------- | ------------------ | ------------------------------------------ | ------------------------------------------------ |
| Navigation（探索与建图）          | 路网构建、绕障策略 | 从当前到目标区域；动态障碍出现如何重规划？ | `connects_to@t`、`blocked_by@t`、`reach()` |
| Object Retrieval（资源获取）      | 依赖解析、启用顺序 | 目标被锁/遮挡，怎样最小代价解锁并取回？    | `need(goal)`、`requires`、`locked@t`       |
| Action Planning（多步编排）       | 前置-后置-并发     | 找钥匙→开门→转运：如何编队与并发？       | `conflicts()`、`occupancy@t`、`simulate()` |
| Object Manipulation（转运与放置） | 载荷与容器约束     | 单/多手限制、尺寸/容量、堆叠策略           | `fit()`、`capacity()`、`carrying@t`        |
| Language→Action（任务落地）      | 语义编译与约束绑定 | 指令到约束满足与可执行计划                 | `need()` + 语义对齐到 `preconds/effects`     |
| State Tracking（时序态）          | 可解释更新         | 谁在拿杯子？设备何时空闲？                 | 事件日志→`ΔKG`、`t_start/t_end`            |
| Constraint Reasoning（合规模型）  | 规则与情境         | 禁拿烫物/禁入区域/先断电再维修             | `rule—[prohibits]→action@context`            |

# 评测指标（系统级）

* **任务成功率** （宏观目标达成）/** ** **阶段成功率** （phase-level）。
* **依赖闭包最小性** （取最少资源/步骤完成）与 **能耗/时间** 。
* **安全/合规违规率** 、 **失败可解释性** （给出触发规则/证据）。
* **地图质量** （拓扑正确率、可达性误差）。
* **鲁棒性** （环境扰动/遮挡/设备占用变化下成功率）。
* **指令到计划的一致性** （语义-执行对齐分数）。

# 任务规范模板（YAML）

```yaml
task_id: NAV-RET-001
objective: "将实验杯从LabA的桌面转运至LabB的加热台，并在80°C加热5分钟后放入干燥柜"
capabilities: [Explore&Map, Acquire&Enable, Transfer, Prepare&Use, Organize&Restore, Safety]
constraints:
  - rule: "不可在湿区通行"
  - rule: "玻璃器皿不可与金属工具同一容器"
dependencies:
  - need: { resource: "power", for: "heater" }
  - need: { resource: "permission", for: "dry_cabinet" }
quality_criteria:
  - temp: "80±3°C"
  - time: "300±10s"
evaluation:
  success: "目标物在干燥柜内，过程无违规，参数达标"
  metrics: [task_success, time_cost, violations, map_quality]
```

# 计划生成与执行（前瞻型策略）

1. **语义编译** ：将自然语言目标编译为** **`goal_spec`（谓词集合+容差）。
2. **依赖闭包** ：`need(goal_spec)` 自动展开钥匙/电源/权限。
3. **多目标排序** ：基于代价-风险-资源占用做线性化与并发划分。
4. **策略抽象** ：从宏观阶段→策略模板（如“先启用→再加工→后转运”）。
5. **时序验证** ：`simulate(plan)` 发现冲突（设备占用、禁区规则）并整改。
6. **在线修正** ：观测触发** **`ΔKG`，调用** **`reach()`/`conflicts()` 局部重规划。

# 具体替换你原表的“宏观化”写法（示例）

* **TextWorld | 资源获取（宏观）**
  * 高层流程：`探索与建图 → 依赖闭包(钥匙/权限) → 访问与转运 → 组织与复原`
  * 关键查询：`need(goal=retrieve(key)->open(chest)) + reach(curr, chest) + conflicts(subtasks)`
* **ALFWorld | 工艺流程（加热/清洁）（宏观）**
  * 高层流程：`资源启用(通电/解锁) → 过程控制(温/时闭环) → 质量验证 → 复原`
  * 关键查询：`afford(device)=heat(params) + occupancy(device,t) + rule(prohibits)`
* **ALFWorld | 放置与编组（宏观）**
  * 高层流程：`容器能力匹配 → 批量排序(类别/位置) → 放置与检查`
  * 关键查询：`fit(item, container) + capacity(container) + policy(sort_by=category)`

# 开发接口草案（便于实现）

```python
kg.need(goal_spec)           # 依赖展开：返回必需资源与先后关系
kg.reach(src, dst, payload)  # 可达性/最短路/绕障说明
kg.afford(entity)            # 可用操作与参数域
kg.fit(item, container)      # 尺寸/形状约束判断
kg.conflicts(tasks)          # 资源/时序冲突与消解建议
kg.simulate(plan)            # 前向验证，返回ΔKG与违规断言
kg.apply(event)              # 日志回放，时变状态更新
```

# 你可以马上用的“基准集切片”

* **Slice-A（探索+启用）** ：未知地图 + 上锁设备 → 找到并启用产生能力的资源（电源/钥匙/权限）。
* **Slice-B（并发转运）** ：多对象、多容器、设备占用 → 冲突最小化编排。
* **Slice-C（安全工艺）** ：热/脏/ fragile 多属性物体 → 合规约束下加工与验收。
* **Slice-D（语言到行动）** ：多约束指令 → 语义编译、依赖闭包、在线重规划。

---

如果你愿意，我可以把上面的**数据模式 + API**整理成一份最小可用的 schema（JSON/TTL）和一套 **评测脚本骨架** （Python），直接跑在 TextWorld/ALFWorld 的桥接层上。





好的 👍 我来帮你把前面宏观层面的任务框架整理成 **表格形式** ，便于直观查看和对比。

---

## 宏观基准任务谱系表

| 基准任务                                 | 决策核心                | 宏观问题模板                                             | 知识图谱关键设计（时变）                                         |
| ---------------------------------------- | ----------------------- | -------------------------------------------------------- | ---------------------------------------------------------------- |
| **Navigation** 探索与建图          | 路径规划、空间推理      | 如何从当前位置移动到目标？若路径被障碍物阻挡，如何绕行？ | `connects_to@t`、`blocked_by@t`、`reach()`                 |
| **Object Retrieval** 资源获取      | 动作选择、依赖解析      | 目标物品被锁或遮挡时，如何解锁并取回？                   | `need(goal)`、`requires`、`locked@t`                       |
| **Action Planning** 多步编排       | 前置-后置顺序、并发调度 | 为了完成目标，需要哪些先后步骤？如何减少冲突？           | `conflicts()`、`simulate()`、`occupancy@t`                 |
| **Object Manipulation** 转运与放置 | 载荷与容量约束          | 如何搬运/放置物品？如果双手已满怎么办？                  | `fit(item,container)`、`capacity(container)`、`carrying@t` |
| **Language→Action**指令落地       | 自然语言→可执行计划    | “把钥匙从抽屉里拿出来放到桌子上”，如何编译为行动？     | `need()` + 语义对齐 `preconds/effects`                       |
| **State Tracking** 动态更新        | 状态迁移、解释性        | 当物品被拿起/设备被占用时，如何更新图谱？                | `ΔKG`、`t_start/t_end`                                      |
| **Constraint Reasoning** 约束推理  | 安全与合规、条件依赖    | 使用钥匙前必须解锁抽屉，如何表达并验证？                 | `rule—[prohibits]→action@context`                            |

---

## 宏观任务流程与查询 API

| 宏观任务                        | 高层流程阶段                          | 关键 KG 查询                                      |
| ------------------------------- | ------------------------------------- | ------------------------------------------------- |
| **探索与建图**            | 环境扫描 → 建立拓扑 → 动态更新      | `reach(from,to)` + `blocked_by(obj)`          |
| **资源获取**              | 依赖解析 → 解锁/启用 → 取回资源     | `need(goal)` + `requires(container,key)`      |
| **转运与放置**            | 路径规划 → 搬运 → 放置 → 校验      | `fit(item,container)` + `capacity(container)` |
| **工艺处理（清洁/加热）** | 设备启用 → 参数控制 → 质量验证      | `afford(device)` + `occupancy(device,t)`      |
| **组织与复原**            | 分类/排序 → 批量放置 → 恢复环境     | `policy(sort_by=category)`                      |
| **安全与合规**            | 风险检查 → 条件执行 → 违规阻止      | `rule(prohibits)` + `conflicts(tasks)`        |
| **多目标协调**            | 并行/串行编排 → 冲突检测 → 优化调度 | `conflicts()` + `simulate(plan)`              |

---

## 任务规范模板（YAML 片段示例）

| 字段                 | 描述                                    |
| -------------------- | --------------------------------------- |
| `task_id`          | 任务标识                                |
| `objective`        | 宏观目标描述                            |
| `capabilities`     | 涉及的能力阶段（探索/启用/转运/加工等） |
| `constraints`      | 规则与限制（如安全、容器容量）          |
| `dependencies`     | 前置资源（电源、钥匙、权限）            |
| `quality_criteria` | 成功的量化指标（温度、时间等）          |
| `evaluation`       | 成功定义与评测指标                      |

---

要不要我帮你把**不同环境（TextWorld / ALFWorld）下的宏观任务对照表**也做出来？这样你能直接看出两个环境的差异和共性。



好的 ✅ 我帮你整理一个** ** **TextWorld vs ALFWorld 宏观任务对照表** ，把两个环境映射到统一的宏观任务框架里，方便横向比较。

---

## TextWorld & ALFWorld 宏观任务对照表

| 环境                     | 宏观任务类别                                 | 典型任务目标                                    | 高层流程阶段                             | 关键 KG 查询/推理                                   |
| ------------------------ | -------------------------------------------- | ----------------------------------------------- | ---------------------------------------- | --------------------------------------------------- |
| **TextWorld**      | **Navigation（探索与建图）**           | 找到目标房间或位置                              | 扫描环境 → 建立拓扑 → 路径规划 → 绕障 | `reach(curr, target)` + `blocked_by(obj)`       |
| **TextWorld**      | **Object Retrieval（资源获取）**       | 找到钥匙并取回目标物品                          | 依赖解析 → 解锁/启用 → 拿取物品        | `need(goal)` + `requires(container,key)`        |
| **TextWorld**      | **Action Planning（多步编排）**        | 开锁 → 打开 → 通过 → 获取目标                | 前置-后置链条 → 多步组合 → 状态更新    | `simulate(plan)` + `conflicts(tasks)`           |
| **ALFWorld**       | **Cleaning（工艺处理）**               | 用合适工具清洁物体                              | 工具选择 → 清洁执行 → 状态转化         | `afford(device)` + `need(tool)`                 |
| **ALFWorld**       | **Heating（工艺处理）**                | 把物体加热到指定温度                            | 启动设备 → 控制温度/时间 → 验证结果    | `afford(device=heater)` + `occupancy(device,t)` |
| **ALFWorld**       | **Placing（转运与放置）**              | 把物品放入容器或指定位置                        | 检查容器容量 → 搬运放置 → 校验状态     | `fit(item,container)` + `capacity(container)`   |
| **ALFWorld**       | **Organizing（组织与复原）**           | 将多物体按类别/位置排序                         | 分类 → 批量放置 → 最优布局             | `policy(sort_by=category)`                        |
| **通用（TW+ALF）** | **Constraint Reasoning（安全与合规）** | 禁止在特定条件下执行（如 fragile、locked、hot） | 条件检测 → 顺序安排 → 违规阻止         | `rule(prohibits)` + `conflicts(tasks)`          |
| **通用（TW+ALF）** | **State Tracking（动态更新）**         | 跟踪谁持有物品、设备是否空闲                    | 动作执行 → KG 更新 → 时间戳记录        | `ΔKG` + `t_start/t_end`                        |

---

## 总结

* **TextWorld** 偏重在** ***空间推理* 和** ** *依赖解析* （钥匙/锁/路径）。
* **ALFWorld** 偏重在** ***工艺处理* 和** ** *物品操作* （加热/清洁/放置/分类）。
* **通用任务** （Constraint Reasoning & State Tracking）跨两个环境都存在，是 **宏观框架的核心支撑能力** 。

---

要不要我再帮你做一个** ** **任务阶段 vs KG 查询矩阵表** ，把每个宏观阶段对应的典型 KG API 一起列出来？这样更像“操作手册”。
